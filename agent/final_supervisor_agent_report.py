from dotenv import load_dotenv
load_dotenv()
from langchain_openai import ChatOpenAI

from langgraph_supervisor import create_supervisor
from langgraph.prebuilt import create_react_agent
from langchain.agents import AgentExecutor
from typing_extensions import Annotated, TypedDict
from typing import Callable, Literal, Optional, Sequence, Type, TypeVar, Union, cast, List, Tuple, Any
from langchain_core.messages import AIMessage, BaseMessage, SystemMessage, ToolMessage
from langgraph.graph.message import add_messages
from langgraph.graph import StateGraph
from langgraph.prebuilt.tool_node import ToolNode, tools_condition
from langgraph.graph import MessagesState, START, END
from langgraph.types import Command
from langchain_core.messages import HumanMessage, AIMessage
from pydantic import BaseModel, Field
from langchain_core.runnables import RunnablePassthrough, RunnableLambda
from langchain_core.tools import tool
import json
from fpdf import FPDF
import os
import datetime

from agent.sql_react_agent_llama import SQL_SUBAGENT, make_dataframe
from agent.viz_agent_memory import VIZ_AGENT
from agent.initiate_llm import gpt_llm, llama_llm

import pandas as pd

class AgentState(TypedDict):
    """The state of the agent."""
    messages: Annotated[Sequence[BaseMessage], add_messages]
    question: Annotated[str, Field(description="The user question")]
    sql_query: Annotated[str, Field(description="The SQL query generated by the agent")]
    results: List[List[Union[int, float, str, bool]]] = Field(..., description="The results returned by the SQL agent as a list of tuples.")
    df: pd.DataFrame = Field(..., description="The table returned by the make_table node as a pandas dataframe.")
    python_visualization_code: Annotated[str, Field(description="The Python code to visualize the results")]
    report_states: List[dict] = Field(..., description="The states of the report generation process")


def nl2sql_node(state: AgentState) -> Command[Literal["supervisor"]]:
    # last = state['messages'][-1]
    question = state["question"]
    try:
        question = json.loads(question)
        question = question["question"]
    except json.JSONDecodeError:
        pass        
    # print(last.content)
    result = SQL_SUBAGENT.invoke({"messages": [HumanMessage(content=question)]})
    return Command(
        update={
            "messages": [
                HumanMessage(content="sql_agent Result Message: GENERATED SQL AND RESULTS => " + result["messages"][-1].content, name="sql_agent")
            ],
            # "question": question,
            "sql_query": json.loads(result["messages"][-1].content)['query'],
            "results": json.loads(result["messages"][-1].content)['result'],
        },
        goto="supervisor",
    )

def make_table_node(state: AgentState) -> Command[Literal["supervisor"]]:
    query = state["sql_query"]
    results = state["results"]
    df = make_dataframe(query, results)
    return Command(
        update={
            "messages": [
                HumanMessage(content=f"make_table Result Message: Here is the table I created from the results: {str(df)}", name="make_table")
            ],
            "df": df,
        },
        goto="supervisor",
    )

def viz_node(state: AgentState) -> Command[Literal["supervisor"]]:
    question = state["question"]
    df = state["df"]
    results = state["results"]
    viz_agent_state = {
        "question": question,
        "df": df,
        "results": results,
        "messages": [],
        "error": ""
    }

    response = VIZ_AGENT.invoke(viz_agent_state)
    viz_code = response["generation"].imports + "\n" + response["generation"].code
    return Command(
        update={
            
            "messages": [
                HumanMessage(content=f"viz_agent Result Message: Here is the visualization code for plotting the data:\n {viz_code}", name="viz_agent")
            ],
            "python_visualization_code": viz_code,
        },
        goto="supervisor",
    )

def report_gen_node(state: AgentState) -> Command[Literal["supervisor"]]:
    states_list = state["report_states"]
    pdf = FPDF()
    cnt = 1
    
    for report_state in states_list:
        pdf.add_page()
        pdf.set_font("Arial", size=12)

        print("REPORT STATE: ", report_state)

        # Get user's question
        question = report_state.get("question", "")

        # Get visualization code
        viz_path = report_state.get("img_path", "")

        summary = report_state.get("summary", "")

        # Add title
        pdf.cell(200, 10, txt=f"Analysis #{cnt}", ln=True, align='C')
        pdf.ln(10)

        # Add user's question
        pdf.set_font("Arial", "B", 12)
        pdf.cell(0, 10, txt="Question:", ln=True)
        pdf.set_font("Arial", size=12)
        pdf.multi_cell(0, 10, txt=question)
        pdf.ln(5)

        # Generate and include visualization
        if viz_path:
            # Execute visualization code
            
            pdf.set_font("Arial", "B", 12)
            pdf.cell(0, 10, txt="Visualization:", ln=True)
            pdf.image(viz_path, x=10, w=180)
            pdf.ln(5)
            # Clean up
            # os.remove(viz_path)
        
        if summary:
            # Add summary
            pdf.set_font("Arial", "B", 12)
            pdf.cell(0, 10, txt="Summary:", ln=True)
            pdf.set_font("Arial", size=12)
            pdf.multi_cell(0, 10, txt=summary)
            pdf.ln(5)
        
        cnt += 1
    
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"reports/report_{timestamp}.pdf"
    pdf.output(filename)

    return Command(
        update={
            
            "messages": [
                HumanMessage(content=f"report_agent Result Message: Report has been generated and saved as {filename}", name="report_agent")
            ],
            "report_states": []
        },
        goto="supervisor",
    )


# Define available agents
members = ["sql_agent", "make_table", "viz_agent", "report_agent"]
# Add FINISH as an option for task completion
options = members + ["FINISH"]

supervisor_memory_prompt = (
"""
You are a supervisor agent named "SQLOrchestrator" tasked with managing the following workers: {members}.

Your job is to orchestrate a multi-step pipeline to answer the user's latest query while handling follow-up questions based on the conversation history. You will examine the latest user message along with the conversation history to decide which worker to invoke next.

**Analyze the Latest Message and Conversation History**
- Use the conversation history and the latest message to determine the user's intent
- Either the user asks a question about the analysis/metrics of data as the very first message - in which case the pipeline starts from sql_agent and goes through all the steps including the table construction and visualization code generation.
- Or the user asks a followup question about previous results in the conversation history - and your task is to decide wether to start again from sql_agent or route to a different agent based on the user's intent:
- If the user asks to generate a report or save the results, route to `report_agent`.

   1. **SQL Generation & Execution**
      - *Routing logic based on user's intent*:
         - **New Query**: If the latest message is from the user and introduces a new question unrelated to the previous data (e.g., asking about a different table, metric, or dataset), route to `sql_agent`"
         - **Modify Query**: If the latest message is from the user and modifies the previous query but is still about getting some metrics/analysis from data (e.g., "Now group by department instead" or "Filter for 2023"), again reset and start from `sql_agent`.
      - The `sql_agent` will generate `sql_query`, execute it, populate `results`, and append its result message to the history.

   2. **Table Construction**
      - *Routing logic based on user's intent*:
         *ALWAYS* route to `make_table` *ONLY AFTER* `sql_agent` has appended its result message - which will be the last message in the conversation history.
      - The `make_table` worker will convert `results` into a dataframe and append its result message.
   
   3. **Visualization Code**
      - *Routing logic based on user's intent*:
         - Route to `viz_agent` *ONLY IF* one of these following conditions is met:
            - `make_table` has appended its result message - which will be the last message in the conversation history.
            - If the latest message is from the user and requests a different visualization of the same data (e.g., "Show this as a line graph" or "Make it a pie chart").
      - The `viz_agent` will generate Python code for visualization and append its result message.
   
   4. **Report Generation**
      - *Routing logic based on user's intent*:
         - *ONLY* if the latest message is from the user and requests to generate a report or save the results (e.g., "Generate a report" or "Save this as a PDF"), route to `report_agent`.
      - The `report_agent` will generate a report based on the conversation history and append its result message.
   
   5. **Finish & Respond**
      - If all necessary result messages in the pipeline have been appended (`sql_agent` to `make_table` and then to `viz_agent`, and if required - `report_agent`), and the latest message doesn’t require further processing:
         - The latest message is from the `viz_agent` itself, so no new action is needed, route to `FINISH`.
         - The latest message is from the `report_agent`, so no new action is needed, route to `FINISH`.
         - The latest message is from the user and asks only for a summary or clarification of the previous results and no intent to route to any other worker, route to `FINISH`.
      - When routing to `FINISH`, produce a natural-language final answer that:
         - Addresses the latest user message.
         - Summarizes the dataframe/results form the latest data used from the history (e.g., key metrics or trends).
         - Includes insights or answers specific to the user’s latest query.
         - *DO NOT* include the python code only natural language summary.

- When routing to `sql_agent`, or `viz_agent`, also generate a input `query` for the next worker based on the latest user message and the conversation history. This will help the next worker understand the context and intent of the user's request.
   - Specifically for `sql_agent` the query should be the latest user message.
   - Specifically for `viz_agent` the query should either be the latest user message if the user is asking for a different visualization of the same data as the latest message, or the same query used previously for `sql_agent` if the latest message is the result message from `make_table`.
"""
)

# Define router type for structured output
class Router(TypedDict):
    """Worker to route to next. If no workers needed, route to FINISH - AND give the final answer."""

    """The worker to route to next."""
    next: Literal["sql_agent", "make_table_node", "viz_agent", "FINISH"]
    """The query for the next worker. (if not FINISH)"""
    query: str
    """The final answer to the user's question if routing to FINISH."""
    final_answer: str

# Create supervisor node function
def supervisor_node(state: AgentState) -> Command[Literal["sql_agent", "make_table_node", "viz_agent", "report_agent", "__end__"]]:
    # messages = [
    #     {"role": "system", "content": supervisor_memory_prompt},
    # ] + state["messages"]
    print("\n\n========BACK TO SUPERVISOR========\n")

    state_info = {k: v for k, v in state.items() if k != 'messages'}

    messages = [
        {"role": "system", "content": supervisor_memory_prompt}
        # {"role": "user", "content": f"AgentState: {json.dumps(state_info, default=str)}"}
    ] + state["messages"]
    
    # print("INVOKING WITH STATE INFO AND MESSAGES\n", state_info, "\n==\n", state["messages"])
    response = gpt_llm.with_structured_output(Router).invoke(messages)
    goto = response["next"]
    print(f"Next Worker: {goto}")

    if goto == "sql_agent":
        return Command(update={
            "question": response["query"],
            "sql_query": "",
            "results": "",
            "df": "",
            "python_visualization_code": ""
        } ,goto=goto)
    elif goto == "viz_agent":
        return Command(update={
            "question": response["query"],
            "python_visualization_code": ""
        }, goto=goto)

        
    elif goto == "FINISH":
        goto = END
        return Command(
            update={
                "messages": [
                    HumanMessage(content="FINAL ANSWER: " +response["final_answer"], name="supervisor")
                ],
            }
            ,goto=goto)
    
    return Command(goto=goto)

builder = StateGraph(AgentState)
builder.add_edge(START, "supervisor")
builder.add_node("supervisor", supervisor_node)
builder.add_node("sql_agent", nl2sql_node)
builder.add_node("make_table_node", make_table_node)
builder.add_node("viz_agent", viz_node)
builder.add_node("report_agent", report_gen_node)
graph = builder.compile()


initial_state = {
    "messages": [HumanMessage(content="Give me the number of employees present from each ethnicity")],
    "question": "",
    "sql_query": "",
    "results": "",
    "df": "",
    "python_visualization_code": ""
}

thread_id = {"configurable": {"thread_id": "1"}}

result = graph.invoke(initial_state, thread_id)

print("DEBUG RESULT: ", result)

SQL_ORCHESTRATOR = graph



